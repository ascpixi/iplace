---
import { TILE_SIZE, CANVAS_WIDTH, CANVAS_HEIGHT, FRAME_CREATE_FORM_URL } from "../config";
import { getCurrentUser } from "../lib/server-auth";

import prisma from "../lib/prisma";
import type * as db from "../prisma/generated/client";

import Button from "../components/Button.astro";
import NoticeOverlay from "../components/NoticeOverlay.astro";
import FrameItem from "../components/FrameItem.astro";
import Details from "../components/Details.astro";
import Modal from "../components/Modal.astro";

const currentUser = await getCurrentUser(Astro);
let userFrames: db.Frame[] = [];
if (currentUser) {
  userFrames = await prisma.frame.findMany({
    where: { ownerId: currentUser.id }
  })
}
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
    <link rel="preload" href={FRAME_CREATE_FORM_URL} as="document" />
		<title>&lt;iplace&gt;</title>
	</head>

  <style is:global>
    @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap');

    * {
      box-sizing: border-box;
      font-family: "IBM Plex Mono", "Cascadia Code", "JetBrains Mono", "Consolas", monospace;
    }

    html, body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      border: none;
    }

    body {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      background: #aaa;
    }

    body, main {
      user-select: none;
    }

    main {
      background: #fff;
    }

    main.place-mode {
      background-image: 
        linear-gradient(to right, #ddd 1px, transparent 1px),
        linear-gradient(to bottom, #ddd 1px, transparent 1px);
      background-size: 100px 100px;
    }

    main.frame-nofocus iframe {
      pointer-events: none;
    }

    #hover-tile {
      position: absolute;
      width: 100px;
      height: 100px;
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid #000;
      pointer-events: none;
      display: none;
      z-index: 5;
    }

    .valid-placement-overlay {
      position: absolute;
      width: 100px;
      height: 100px;
      background: rgba(0, 255, 0, 0.2);
      border: 1px solid #00aa00;
      pointer-events: all;
      cursor: pointer;
      z-index: 4;
    }

    main iframe {
      position: absolute;
    }

    iframe {
      border: none;
    }

    body > * {
      position: absolute;
      top: 0;
      left: 0;
    }

    p {
      margin: 0;
    }

    #toolbox {
      width: 100%;
      height: 100%;
      padding: 2em;
    }

    .buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    /* Project selection modal specific styling */
    #project-selection-modal .modal-content {
      padding: 4em;
    }

    .modal-loading {
      text-align: center;
      padding: 2em;
    }

    .modal-error {
      display: none;
      text-align: center;
      padding: 2em;
    }

    .project-instruction {
      margin-bottom: 1em;
    }

    .modal-buttons {
      margin-top: 1em;
    }

    .selection-hint {
      font-size: 0.9em;
      color: #666;
      text-align: center;
      margin: 0.5em 0;
    }

    .project-checkboxes {
      max-height: 300px;
      overflow-y: auto;
      border: 2px solid #000;
      padding: 1em;
      margin: 1em 0;
      background: #fff;

      .project-item {
        display: flex;
        align-items: center;
        gap: 0.5em;
        padding: 0.5em;
        cursor: pointer;
        border: 1px solid transparent;
        transition: background .25s, border-color .25s;

        &:hover {
          background: #f0f0f0;
          border-color: #000;
        }

        input[type="checkbox"] {
          appearance: none;
          width: 18px;
          height: 18px;
          border: 2px solid #000;
          background: #fff;
          margin: 0;
          cursor: pointer;
          flex-shrink: 0;

          &:checked {
            background: #000;
          }

          &:focus {
            outline: none;
          }

          &:hover {
            border-color: #000;
          }
        }

        label {
          cursor: pointer;
          flex: 1;
          font-weight: 400;
        }

        .project-name {
          flex: 1;
        }

        .project-time {
          font-size: 0.8em;
          color: #666;
          font-weight: 300;
        }
      }
    }

    .modal-hidden {
      display: none;
    }

    .no-frames-message {
      padding: 1em;
    }

  </style>

	<body>
    <main
      style={{
        width: `${TILE_SIZE * CANVAS_WIDTH}px`,
        height: `${TILE_SIZE * CANVAS_HEIGHT}px`
      }}
    />

    <NoticeOverlay id="notice-overlay">
      <span slot="title">Hack Club's <b>&lt;iplace&gt;</b></span>
      
      <p>
        This is a public canvas of websites inside <b>&lt;iframe&gt;</b> elements. Each hour of coding
        allows you to place one 100x100px tile and gives you <b>$5</b> in hosting credit!
      </p>

      <p>
        Hold <b>Shift</b> and drag to explore the canvas.<br>
        <span id="countdown-timer"></span>
      </p>

      <div class="buttons">
        { currentUser ? (
          <Details summary="Your frames">
            <div class="content">
              { userFrames.length == 0 && <p class="no-frames-message">You have no frames yet!</p> }
              
              { userFrames.map(frame => {
                const availableTiles = frame.isPending ? 0 : Math.max(0, Math.floor((frame.approvedTime || 0) / 3600) - frame.placedTiles);
                return (
                  <FrameItem 
                    frameId={frame.id}
                    title={frame.url}
                    url={frame.url}
                    availableTiles={availableTiles}
                    isPending={frame.isPending}
                  />
                )
              }) }
              
              <Button id="btn-create-frame">Create a frame</Button>
            </div>
          </Details>
        ) : (
          <Button id="btn-login">Log in with Hack Club's Slack</Button>
        ) }

        <Button id="btn-random">Take me somewhere random</Button>
      </div>
    </NoticeOverlay>

    { currentUser && (
      <Modal id="create-frame-modal" title="Create frame" closeButtonId="modal-close" hidden>
        <iframe id="create-frame-iframe" sandbox="allow-same-origin allow-scripts allow-forms" width="100%" height="100%"></iframe>
      </Modal>
    ) }

    { currentUser && (
      <Modal id="project-selection-modal" title="Select Hackatime Projects" closeButtonId="project-modal-close" class="modal-hidden">
        <div id="project-loading" class="modal-loading">
          Loading projects...
        </div>
        <div id="project-list" class="modal-hidden">
          <p class="project-instruction"><strong>Select at least one project</strong> to associate with this frame:</p>
          <div id="project-checkboxes" class="project-checkboxes"></div>
          <div class="buttons modal-buttons">
            <Button id="continue-with-projects" disabled>Continue</Button>
            <p id="selection-hint" class="selection-hint">Please select at least one project to continue</p>
          </div>
        </div>
        <div id="project-error" class="modal-error">
          <p>Failed to load projects. You can continue without selecting projects.</p>
          <div class="buttons modal-buttons">
            <Button id="continue-without-projects">Continue anyway</Button>
          </div>
        </div>
      </Modal>
    ) }

    <div id="hover-tile"></div>
		
    <script>
      // Main canvas controller
      import { CANVAS_HEIGHT, CANVAS_WIDTH, TILE_SIZE } from "../config";
      import { assert, type Vector2 } from "../util";
      import type { ApiTile, ApiFrame, ApiMapResponse } from "./api/map";

      const body = document.body;
      const main = document.querySelector("main")!;

      let offset = { x: 0, y: 0 };
      let dragStart = { x: 0, y: 0 };
      let isDragging = false;
      let isShiftPressed = false;
      
      // Place mode variables
      let isPlaceMode = false;
      let clickStartPos: Vector2 | null = null;
      let currentHoverTileX: number | null = null;
      let currentHoverTileY: number | null = null;
      let currentPlacingFrame: number | null = null;
      let mapData: { tiles: Array<{x: number, y: number, frame: number}> } | null = null;

      const map: ApiMapResponse = await fetch("/api/map").then(x => x.json());
      console.log("(ok) map fetched!", map);

      const frames = new Map(map.frames.map(x => [x.id, x]));

      const tiles = new Array<ApiTile | undefined>(CANVAS_WIDTH * CANVAS_HEIGHT);
      for (const tile of map.tiles) {
        tiles[tile.x + (tile.y * CANVAS_WIDTH)] = tile;
      }

      const getTileByCoord = (x: number, y: number) => tiles[x + (y * CANVAS_WIDTH)];
      const getFrameById = (id: number) => frames.get(id);

      const loadedFrameIds = new Set<number>();

      // Hash update throttling
      let hashUpdateTimeout: ReturnType<typeof setTimeout> | null = null;
      function updateHashThrottled(offset: Vector2) {
        if (hashUpdateTimeout !== null) {
          clearTimeout(hashUpdateTimeout);
        }
        
        hashUpdateTimeout = setTimeout(() => {
          // Negate coordinates for hash-space (positive values represent movement right/down)
          const hashX = Math.round(-offset.x);
          const hashY = Math.round(-offset.y);
          const newHash = `${hashX},${hashY}`;
          
          if (window.location.hash !== `#${newHash}`) {
            window.location.replace(`${window.location.pathname}${window.location.search}#${newHash}`);
          }
          hashUpdateTimeout = null;
        }, 500);
      }

      // Get random offset for a tile with a frame
      function getRandomTileOffset(): Vector2 {
        // Pick a random tile that has a frame
        const tilesWithFrames = map.tiles.filter(tile => {
          const frame = map.frames.find(f => f.id === tile.frame);
          return frame !== undefined;
        });
        
        if (tilesWithFrames.length > 0) {
          const randomTile = tilesWithFrames[Math.floor(Math.random() * tilesWithFrames.length)];
          // Convert tile coordinates to screen-space offset (center the view on this tile)
          const tileScreenX = randomTile.x * TILE_SIZE;
          const tileScreenY = randomTile.y * TILE_SIZE;
          
          // Center the viewport on this tile by offsetting to bring it to center
          const viewportCenterX = window.innerWidth / 2;
          const viewportCenterY = window.innerHeight / 2;
          
          const offset = {
            x: viewportCenterX - tileScreenX,
            y: viewportCenterY - tileScreenY
          };
          
          console.log("Using random tile:", randomTile, "converted to offset:", offset);
          return offset;
        } else {
          // Fallback if no tiles with frames exist
          console.log("No tiles with frames found, using origin");
          return { x: 0, y: 0 };
        }
      }

      // Initialize offset from hash or random coordinates
      function initializeOffset() {
        const hash = window.location.hash.substring(1); // Remove the '#'
        let initialOffset = { x: 0, y: 0 };
        
        if (hash && hash.includes(',')) {
          // Parse coordinates from hash like "100,200" and negate for screen-space
          const [hashX, hashY] = hash.split(',').map(coord => parseInt(coord.trim()));
          if (!isNaN(hashX) && !isNaN(hashY)) {
            initialOffset = { x: -hashX, y: -hashY };
            console.log("Using coordinates from hash:", { hashX, hashY }, "converted to offset:", initialOffset);
          }
        }
        
        if (initialOffset.x === 0 && initialOffset.y === 0) {
          initialOffset = getRandomTileOffset();
        }
        
        return initialOffset;
      }

      // Set initial offset and load frames
      const initialOffset = initializeOffset();
      setOffset(initialOffset);

      /**
       * Converts a screen-space coordinate to a tile-space one.
       */
      function screenToTile(coord: Vector2): Vector2 {
        return {
          x: Math.max(0, Math.floor(coord.x / TILE_SIZE)),
          y: Math.max(0, Math.floor(coord.y / TILE_SIZE))
        };
      }

      async function setOffset(value: Vector2) {
        offset = value;
        main.style.transform = `translate(${offset.x}px, ${offset.y}px)`;
        
        // Update hash with current coordinates (throttled)
        updateHashThrottled(offset);

        const tlTile = screenToTile(value);
        const brTile = screenToTile({
          x: value.x + (CANVAS_WIDTH * TILE_SIZE),
          y: value.y + (CANVAS_HEIGHT * TILE_SIZE)
        });

        // Wait a short while, and check if the value has changed again - if so, we won't bother
        // with updating the tiles that were on the screen for less than (N)ms.
        // await sleep(50);
        if (value.x != offset.x || value.y != offset.y) {
          console.log("Value changed", value, offset);
          return;
        }

        // Load every tile in the visible region.
        for (let x = tlTile.x; x < brTile.x; x++) {
          for (let y = tlTile.y; y < brTile.y; y++) {
            updateTileAt(x, y);
          }
        }

        // Update placement overlays if in place mode
        if (isPlaceMode) {
          showValidPlacementOverlays();
        }
      }

      function setIsDragging(value: boolean) {
        isDragging = value;
        updateCursor();
      }

      function updateCursor() {
        // Update cursor based on state
        if (isDragging) {
          body.style.cursor = "grabbing";
        } else if (isShiftPressed) {
          body.style.cursor = "grab";
        } else {
          body.style.cursor = "default";
        }
        
        // Apply frame-nofocus class when shift is held (panning mode) or in place mode
        main.classList.toggle("frame-nofocus", isShiftPressed || isPlaceMode);
      }

      /**
       * Makes sure the tile at `(x, y)` is loaded, alongside its corresponding `<iframe>` element.
       */
      function updateTileAt(x: number, y: number) {
        const tile = getTileByCoord(x, y);
        if (!tile)
          return; // no tile is present at the given location

        const frame = getFrameById(tile?.frame);
        assert(frame != undefined, `frame ID ${tile.frame} of (${tile.x}, ${tile.y}) is non-existent for updateTileAt`);

        ensureFrameLoaded(frame);
      }

      function ensureFrameLoaded(frame: ApiFrame) {
        if (loadedFrameIds.has(frame.id))
          return;

        console.log("(ensureFrameLoaded) loading frame", frame);

        // Calculate the bounding box of the iframe. The bounding box encapsulates all of the tiles of
        // the frame in a tight fit.
        let x1 = Infinity, y1 = Infinity; // top-left, absolute
        let x2 = -Infinity, y2 = -Infinity; // bottom-right, absolute
        let layoutCount = 0;

        for (const tile of map.tiles) {
          if (tile.frame != frame.id)
            continue;

          layoutCount++;

          if (x1 > tile.x) { x1 = tile.x; }
          if (y1 > tile.y) { y1 = tile.y; }

          if (x2 < tile.x) { x2 = tile.x; }
          if (y2 < tile.y) { y2 = tile.y; }
        }
        
        assert(layoutCount != 0, "ensureFrameLoaded called but no tiles belong to the frame");
        assert(x1 != Infinity && y1 != Infinity, `x1 = ${x1}, y1 = ${y1}`);
        assert(x2 != -Infinity && y2 != -Infinity, `x2 = ${x2}, y2 = ${y2}`);

        const width = (x2 - x1) + 1;
        const height = (y2 - y1) + 1;

        // Now that we computed the width/height, let's check if the layout points form a rectangle.
        // If so, we can skip masking (since this iframe would cover the entire bounding rectangle)
        let needsMask = true;
        if (layoutCount == width * height) {
          needsMask = false;

          for (let x = x1; x < x2; x++) {
            for (let y = y1; y < y2; y++) {
              // If we're missing any tile in the rectangle, that means that we do have to compute a mask.
              const tile = getTileByCoord(x, y);
              if (!tile || tile.frame != frame.id) {
                needsMask = true;
                break;
              }
            }

            if (needsMask)
              break;
          }
        }

        const iframe = document.createElement("iframe");
        iframe.src = frame.url;
        iframe.sandbox = "allow-same-origin allow-scripts";
        iframe.width = `${width * TILE_SIZE}`;
        iframe.height = `${height * TILE_SIZE}`;
        iframe.style.left = `${x1 * TILE_SIZE}px`;
        iframe.style.top = `${y1 * TILE_SIZE}px`;
        iframe.allow = "accelerometer; cross-origin-isolated; gyroscope; magnetometer; encrypted-media";
        iframe.dataset.id = `${frame.id}`;

        // We might not need a mask - if this is a filled rect, then we can skip this step.
        if (needsMask) {
          let mask = `<svg xmlns="http://www.w3.org/2000/svg" width="${width * TILE_SIZE}" height="${height * TILE_SIZE}" viewBox="0 0 ${width * TILE_SIZE} ${height * TILE_SIZE}" fill="#000">`;
          
          for (const tile of map.tiles) {
            if (tile.frame != frame.id)
              continue;

            assert(tile.x >= x1 && tile.y >= y1, `x1 = ${x1}, tile.x = ${tile.x}, y1 = ${y1}, tile.y = ${tile.y}`);
            assert(tile.x <= x2 && tile.y <= y2, `x2 = ${x2}, tile.x = ${tile.x}, y2 = ${y2}, tile.y = ${tile.y}`);

            mask += `<rect width="${TILE_SIZE}" height="${TILE_SIZE}" x="${(tile.x - x1) * TILE_SIZE}" y="${(tile.y - y1) * TILE_SIZE}" fill="#fff" />`;
          }

          mask += "</svg>";

          iframe.style.maskImage = `url("data:image/svg+xml;base64,${btoa(mask)}")`;
          iframe.style.maskMode = "luminance";
        }

        main.append(iframe);
        loadedFrameIds.add(frame.id);

        console.log("(ensureFrameLoaded) iframe created:", iframe);
      }

      function refreshFrame(frameId: number) {
        // Remove existing iframe for this frame
        const existingIframe = document.querySelector(`iframe[data-id="${frameId}"]`);
        if (existingIframe) {
          existingIframe.remove();
        }
        
        // Remove from loaded frames set so it can be recreated
        loadedFrameIds.delete(frameId);
        
        // Find the frame data and reload it
        const frame = map.frames.find(f => f.id === frameId);
        if (frame) {
          ensureFrameLoaded(frame);
        }
      }

      body.addEventListener("mousedown", (ev) => {
        // Only start dragging if Shift key is held down
        if (ev.shiftKey) {
          setIsDragging(true);
          dragStart = {
            x: ev.clientX - offset.x,
            y: ev.clientY - offset.y
          };
        }

        if (isPlaceMode) {
          clickStartPos = { x: ev.clientX, y: ev.clientY };
        }
      });

      body.addEventListener("mousemove", (ev) => {
        if (!isDragging)
          return;

        setOffset({
          x: ev.clientX - dragStart.x,
          y: ev.clientY - dragStart.y
        });
      });

      body.addEventListener("mouseup", (ev) => {
        if (isDragging) {
          setIsDragging(false);
        }
      });

      body.addEventListener("touchstart", (ev) => {
        const touch = ev.touches[0];
        setIsDragging(true);
        dragStart = {
          x: touch.clientX - offset.x,
          y: touch.clientY - offset.y
        };

        if (isPlaceMode) {
          clickStartPos = { x: touch.clientX, y: touch.clientY };
        }
      });

      body.addEventListener("touchmove", (ev) => {
        if (!isDragging)
          return;

        const touch = ev.touches[0];
        setOffset({
          x: touch.clientX - dragStart.x,
          y: touch.clientY - dragStart.y
        });
      });

      body.addEventListener("touchend", (ev) => {
        setIsDragging(false);
      });

      // Track shift key state for drag mode
      document.addEventListener("keydown", (ev) => {
        if (ev.key === "Shift" && !isShiftPressed) {
          isShiftPressed = true;
          updateCursor();
        }
      });

      document.addEventListener("keyup", (ev) => {
        if (ev.key === "Shift" && isShiftPressed) {
          isShiftPressed = false;
          updateCursor();
          // If we were dragging and shift is released, stop dragging
          if (isDragging) {
            setIsDragging(false);
          }
        }
      });

      const hoverTile = document.querySelector<HTMLDivElement>("#hover-tile")!;

      function hideValidPlacementOverlays() {
        // Remove all existing valid placement overlays
        const overlays = document.querySelectorAll('[data-valid-overlay]');
        overlays.forEach(overlay => overlay.remove());
      }

      function showValidPlacementOverlays() {
        if (!currentPlacingFrame || !mapData) return;
        
        // Hide existing overlays first
        hideValidPlacementOverlays();
        
        // Get existing tiles for current frame
        const frameTiles = mapData.tiles.filter(tile => tile.frame === currentPlacingFrame);
        
        // For first tile, don't show overlays (can be placed anywhere)
        if (frameTiles.length === 0) return;
        
        // Find all adjacent positions to existing tiles
        const validPositions = new Set<string>();
        
        frameTiles.forEach(tile => {
          // Check all 4 adjacent positions
          const adjacentPositions = [
            { x: tile.x + 1, y: tile.y },
            { x: tile.x - 1, y: tile.y },
            { x: tile.x, y: tile.y + 1 },
            { x: tile.x, y: tile.y - 1 }
          ];
          
          adjacentPositions.forEach(pos => {
            // Check if position is valid and not occupied
            if (isValidPlacement(pos.x, pos.y)) {
              validPositions.add(`${pos.x},${pos.y}`);
            }
          });
        });
        
        // Create overlay elements for valid positions
        validPositions.forEach(posKey => {
          const [x, y] = posKey.split(',').map(Number);
          
          // Apply the same bounds checking as hover tile
          if (x < 0 || x >= CANVAS_WIDTH || y < 0 || y >= CANVAS_HEIGHT) {
            return;
          }
          
          const overlay = document.createElement('div');
          overlay.className = 'valid-placement-overlay';
          // Position relative to the main element (which is already transformed)
          overlay.style.left = `${x * TILE_SIZE}px`;
          overlay.style.top = `${y * TILE_SIZE}px`;
          overlay.setAttribute('data-valid-overlay', '');
          main.appendChild(overlay);
        });
      }

      async function setPlaceMode(value: boolean, frameId?: number) {
        isPlaceMode = value;
        currentPlacingFrame = value ? (frameId || null) : null;
        main.classList.toggle("place-mode", value);
        hoverTile.style.display = value ? "block" : "none";

        // Update cursor and frame-nofocus class
        updateCursor();

        if (!value) {
          hoverTile.style.display = "none";
          hideValidPlacementOverlays();
        }

        // Load map data when entering place mode
        if (value && !mapData) {
          try {
            const response = await fetch("/api/map");
            mapData = await response.json();
            showValidPlacementOverlays();
          } catch (error) {
            console.error("Failed to load map data:", error);
          }
        } else if (value) {
          showValidPlacementOverlays();
        }

        // Update button text for all place tile buttons
        updatePlaceTileButtonTexts();
      }

      function updatePlaceTileButtonTexts() {
        const buttons = document.querySelectorAll<HTMLButtonElement>('.btn-place-tile');
        buttons.forEach(button => {
          const frameId = parseInt(button.getAttribute("data-frame-id") || "0");
          if (isPlaceMode && currentPlacingFrame === frameId) {
            button.textContent = "Exit place mode";
          } else {
            // Get available tiles count from data attribute if available
            const originalText = button.getAttribute("data-original-text");
            if (originalText) {
              button.textContent = originalText;
            }
          }
        });
      }

      function updateFrameTileCounts(frameId: number, remainingTime: number) {
        // Calculate new available tile count
        const newAvailableTiles = Math.max(0, Math.floor(remainingTime / 3600));
        
        // Find and update the frame info text
        const frameItems = document.querySelectorAll('.frame-item');
        frameItems.forEach(item => {
          const button = item.querySelector('.btn-place-tile') as HTMLButtonElement;
          if (button && parseInt(button.getAttribute('data-frame-id') || '0') === frameId) {
            // Update the "Available tiles: X" text
            const frameInfo = item.querySelector('.frame-info small');
            if (frameInfo) {
              frameInfo.textContent = `Available tiles: ${newAvailableTiles}`;
            }
            
            // Update button text and visibility
            if (newAvailableTiles > 0) {
              const newButtonText = `Place tile (${newAvailableTiles} available)`;
              button.setAttribute('data-original-text', newButtonText);
              
              // Update button text if not currently in place mode for this frame
              if (!(isPlaceMode && currentPlacingFrame === frameId)) {
                button.textContent = newButtonText;
              }
              button.style.display = 'block';
            } else {
              // Hide button if no tiles available
              button.style.display = 'none';
            }
          }
        });
        
        // Update button texts after the count change
        updatePlaceTileButtonTexts();
      }

      function isValidPlacement(x: number, y: number): boolean {
        if (!currentPlacingFrame || !mapData)
          return true;
        
        const frameTiles = mapData.tiles.filter(tile => tile.frame === currentPlacingFrame);
        
        const existingTile = mapData.tiles.find(tile => tile.x === x && tile.y === y);
        if (existingTile && existingTile.frame == currentPlacingFrame)
          return false; // can't place a tile on top of another belonging to the same frame

        // First tile can be placed anywhere that is not occupied.
        if (frameTiles.length === 0)
          return existingTile == null;
        
        // Subsequent tiles can be placed on occupied tiles, but must be adjacent to existing tiles.
        return frameTiles.some(tile => {
          const dx = Math.abs(tile.x - x);
          const dy = Math.abs(tile.y - y);
          return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
        });
      }

      function updateHoverTile(screenCoord: Vector2) {
        if (!isPlaceMode)
          return;

        const canvasX = screenCoord.x - offset.x; // screen-space -> canvas-space coords
        const canvasY = screenCoord.y - offset.y;
        const tileX = Math.floor(canvasX / TILE_SIZE);
        const tileY = Math.floor(canvasY / TILE_SIZE);

        if (tileX < 0 || tileX >= CANVAS_WIDTH || tileY < 0 || tileY >= CANVAS_HEIGHT) {
          // We're out-of-bounds here.
          hoverTile.style.display = "none";
          currentHoverTileX = null;
          currentHoverTileY = null;
          return;
        }

        hoverTile.style.left = `${(tileX * TILE_SIZE) + offset.x}px`;
        hoverTile.style.top = `${(tileY * TILE_SIZE) + offset.y}px`;
        hoverTile.style.display = "block";

        // Update hover tile color based on validity
        const isValid = isValidPlacement(tileX, tileY);
        hoverTile.style.background = isValid ? "rgba(0, 255, 0, 0.3)" : "rgba(255, 0, 0, 0.3)";
        hoverTile.style.borderColor = isValid ? "#00aa00" : "#aa0000";

        currentHoverTileX = tileX;
        currentHoverTileY = tileY;
      }



      // Add event listeners for place tile buttons
      document.addEventListener("click", (ev) => {
        const target = ev.target as Element;
        if (target && target.classList.contains("btn-place-tile")) {
          const frameId = parseInt(target.getAttribute("data-frame-id") || "0");
          if (frameId > 0) {
            // Toggle place mode for this frame
            if (isPlaceMode && currentPlacingFrame === frameId) {
              setPlaceMode(false);
            } else {
              setPlaceMode(true, frameId);
            }
          }
        }
      });

      // Override existing mousemove handler to include place mode
      body.addEventListener("mousemove", (ev) => {
        if (isPlaceMode) {
          updateHoverTile({ x: ev.clientX, y: ev.clientY });
        }
      });

      body.addEventListener("click", (ev) => {
        if (isPlaceMode && clickStartPos) {
          if ((ev.target as Element).closest(".notice")) {
            clickStartPos = null;
            return;
          }
          
          // We don't want to capture clicks that might be drags.
          const deltaX = Math.abs(ev.clientX - clickStartPos.x);
          const deltaY = Math.abs(ev.clientY - clickStartPos.y);
          const maxClickDistance = 5; // pixels
          
          if (
            deltaX <= maxClickDistance &&
            deltaY <= maxClickDistance &&
            currentHoverTileX !== null &&
            currentHoverTileY !== null
          ) {
            handlePlace(currentHoverTileX, currentHoverTileY);
          }
          
          clickStartPos = null;
        }
      });

      async function handlePlace(x: number, y: number) {
        if (!currentPlacingFrame) {
          alert("Select a frame first before placing!");
          return;
        }

        if (!isValidPlacement(x, y)) {
          alert("Sorry, you can't place a tile there!");
          return;
        }

        try {
          const response = await fetch("/api/place-tile", {
            method: "POST",
            headers: {
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              x,
              y,
              frameId: currentPlacingFrame
            })
          });

          if (response.ok) {
            const result = await response.json();
            console.log("Tile placed successfully:", result);
            
            // Update local map data
            if (mapData) {
              mapData.tiles.push({ x, y, frame: currentPlacingFrame! });
            }
            
            // Also update the main map tiles array that ensureFrameLoaded uses
            const newTile = { x, y, frame: currentPlacingFrame! };
            map.tiles.push(newTile);
            
            // Update the tiles lookup array used by getTileByCoord
            tiles[x + (y * CANVAS_WIDTH)] = newTile;
            
            // Update the tile immediately
            updateTileAt(x, y);
            
            // Refresh the frame to recalculate dimensions and mask
            refreshFrame(currentPlacingFrame!);
            
            // Update available tile counts in the UI
            updateFrameTileCounts(currentPlacingFrame!, result.frame?.remainingTime || 0);
            
            // Update overlays for the new placement
            showValidPlacementOverlays();
            
            // Check if more tiles are available, only exit place mode if no more tiles can be placed
            const remainingTime = result.frame?.remainingTime || 0;
            const canPlaceMore = remainingTime >= 3600; // Each tile requires 1 hour (3600 seconds)
            
            if (!canPlaceMore) {
              // Exit place mode if no more tiles can be placed
              setPlaceMode(false);
            }
            // If more tiles can be placed, stay in place mode
          } else {
            const error = await response.json();
            alert(`Error placing tile: ${error.message || "Unknown error"}`);
          }
        } catch (error) {
          console.error("Error placing tile:", error);
          alert("Failed to place tile. Please try again.");
        }
      }

      // Random button functionality
      function randomizeLocation() {
        const newOffset = getRandomTileOffset();
        setOffset(newOffset);
      }

      // Add click handler for random button
      const btnRandom = document.querySelector<HTMLButtonElement>("#btn-random");
      if (btnRandom) {
        btnRandom.addEventListener("click", () => {
          randomizeLocation();
        });
      }
    </script>

    <script>
      // Top-right modal minimize/maximize
      const overlay = document.querySelector<HTMLDivElement>("#notice-overlay")!;
      const control = document.querySelector<HTMLDivElement>("#notice-control")!;
      control.addEventListener("click", () => {
        overlay.classList.toggle("minimized");
        control.innerText = overlay.classList.contains("minimized") ? "[^]" : "[x]";
      });
    </script>

    <script>
      // Login button controller
      const btnLogin = document.querySelector<HTMLButtonElement>("#btn-login");
      if (btnLogin) {
        btnLogin.addEventListener("click", () => {
          const url = new URL("https://slack.com/oauth/v2/authorize");
          url.searchParams.set("client_id", import.meta.env.PUBLIC_SLACK_CLIENT_ID);
          url.searchParams.set("user_scope", "identity.basic,identity.email");
          url.searchParams.set("redirect_uri", `${location.origin}/api/slack-callback`);

          location.href = url.toString();
        });
      }


    </script>

    <script>
      import { FRAME_CREATE_FORM_URL } from "../config";
      import { assert } from "../util";
      import type { ApiHackatimeProjectsResponse } from "./api/hackatime-projects";


      const createFrameModal = document.querySelector<HTMLDivElement>("#create-frame-modal");
      const createFrameIframe = document.querySelector<HTMLIFrameElement>("#create-frame-iframe");
      const modalClose = document.querySelector<HTMLDivElement>("#modal-close");
      
      const projectSelectionModal = document.querySelector<HTMLDivElement>("#project-selection-modal");
      const projectModalClose = document.querySelector<HTMLDivElement>("#project-modal-close");
      const projectLoading = document.querySelector<HTMLDivElement>("#project-loading");
      const projectList = document.querySelector<HTMLDivElement>("#project-list");
      const projectError = document.querySelector<HTMLDivElement>("#project-error");
      const projectCheckboxes = document.querySelector<HTMLDivElement>("#project-checkboxes");
      const continueWithProjects = document.querySelector<HTMLButtonElement>("#continue-with-projects");
      const selectionHint = document.querySelector<HTMLParagraphElement>("#selection-hint");
      const continueWithoutProjects = document.querySelector<HTMLButtonElement>("#continue-without-projects");

      function formatTime(seconds: number): string {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        if (hours > 0) {
          return `${hours}h ${minutes}m`;
        }
        return `${minutes}m`;
      }

      async function openCreateFrameModal(selectedProjects: string[] = []) {
        if (createFrameModal && createFrameIframe) {
          let url = FRAME_CREATE_FORM_URL;
          const params = new URLSearchParams();
          
          if (selectedProjects.length > 0) {
            params.set('hkp', selectedProjects.join(','));
          }
          
          const response = await fetch('/api/create-authorship-token', { method: 'POST' });
          if (!response.ok) {
            console.error("(openCreateFrameModal) /api/create-authorship-token failed!", response, await response.text());
            throw new Error(`/api/create-authorship-token failed with HTTP ${response.status}`);
          }

          const data = await response.json();
          params.set('atk', data.token);

          console.log(`(debug) form query params: ${params.toString()}`);
          
          url += `?${params.toString()}`;

          createFrameIframe.src = url;
          createFrameModal.style.display = "block";
        }
      }

      function closeProjectSelectionModal() {
        if (projectSelectionModal) {
          projectSelectionModal.classList.add("modal-hidden");
        }
      }

      function closeCreateFrameModal() {
        if (createFrameModal && createFrameIframe) {
          createFrameModal.style.display = "none";
          createFrameIframe.src = "";
        }
      }

      async function loadProjects() {
        try {
          if (!projectLoading || !projectList || !projectError || !projectCheckboxes) return;
          
          projectLoading.classList.remove("modal-hidden");
          projectList.classList.add("modal-hidden");
          projectError.classList.add("modal-hidden");

          const response = await fetch("/api/hackatime-projects", { method: "POST" });
          if (!response.ok) throw new Error("Failed to fetch projects");
          
          const data: ApiHackatimeProjectsResponse = await response.json();
          
          projectCheckboxes.innerHTML = "";
          
          if (data.projects.length === 0) {
            projectCheckboxes.innerHTML = "<p>No projects found. Make sure you've worked on your project for at least an hour!</p>";
          } else {
            data.projects.forEach(project => {
              const item = document.createElement("div");
              item.className = "project-item";
              item.innerHTML = `
                <input type="checkbox" id="project-${project.name}" value="${project.name}">
                <label for="project-${project.name}" class="project-name">${project.name}</label>
                <span class="project-time">${formatTime(project.seconds)}</span>
              `;
              
              const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement;
              if (checkbox) {
                checkbox.addEventListener('change', updateContinueButtonState);
              }
              
              projectCheckboxes.appendChild(item);
            });
          }
          
          // Update button state after loading projects
          updateContinueButtonState();
          
          projectLoading.classList.add("modal-hidden");
          projectList.classList.remove("modal-hidden");
        } catch (error) {
          console.error("Failed to load projects:", error);
          if (projectLoading) projectLoading.classList.add("modal-hidden");
          if (projectError) projectError.classList.remove("modal-hidden");
        }
      }

      function getSelectedProjects(): string[] {
        if (!projectCheckboxes) return [];
        const checkboxes = projectCheckboxes.querySelectorAll<HTMLInputElement>('input[type="checkbox"]:checked');
        return Array.from(checkboxes).map(cb => cb.value);
      }

      function updateContinueButtonState() {
        const selectedProjects = getSelectedProjects();
        const hasSelection = selectedProjects.length > 0;
        
        if (continueWithProjects) {
          continueWithProjects.disabled = !hasSelection;
        }
        
        if (selectionHint) {
          selectionHint.classList.toggle("modal-hidden", hasSelection);
        }
      }

      // Create frame button controller
      const btnCreateFrame = document.querySelector<HTMLButtonElement>("#btn-create-frame");
      if (btnCreateFrame) {
        btnCreateFrame.addEventListener("click", () => {
          if (projectSelectionModal) {
            projectSelectionModal.classList.remove("modal-hidden");
            loadProjects();
          }
        });
      }



      if (projectModalClose) {
        projectModalClose.addEventListener("click", closeProjectSelectionModal);
      }

      if (projectSelectionModal) {
        projectSelectionModal.addEventListener("click", (ev) => {
          if (ev.target === projectSelectionModal || (ev.target as Element).classList.contains("modal-backdrop")) {
            closeProjectSelectionModal();
          }
        });
      }

      if (continueWithProjects) {
        continueWithProjects.addEventListener("click", () => {
          const selectedProjects = getSelectedProjects();
          if (selectedProjects.length > 0) {
            closeProjectSelectionModal();
            openCreateFrameModal(selectedProjects);
          }
        });
      }

      if (continueWithoutProjects) {
        continueWithoutProjects.addEventListener("click", () => {
          closeProjectSelectionModal();
          openCreateFrameModal();
        });
      }

      if (modalClose) {
        modalClose.addEventListener("click", closeCreateFrameModal);
      }

      if (createFrameModal) {
        createFrameModal.addEventListener("click", (ev) => {
          if (ev.target === createFrameModal || (ev.target as Element).classList.contains("modal-backdrop")) {
            closeCreateFrameModal();
          }
        });
      }

      // Listen for frame creation completion from iframe
      window.addEventListener("message", (event) => {
        // Verify the origin for security
        if (event.origin !== window.location.origin) {
          return;
        }
        
        if (event.data && event.data.type === "frameCreated") {
          console.log("Frame created:", event.data.frame);
          
          // Close the modal
          closeCreateFrameModal();
          
          // Refresh the page to show the new frame
          window.location.reload();
        }
      });
    </script>

    <script>
      import { END_DATE } from "../config";

      function updateCountdown() {
        const now = new Date();
        const endDate = new Date(END_DATE);
        const timerElement = document.getElementById("countdown-timer");
        
        if (!timerElement) return;

        if (now >= endDate) {
          timerElement.innerHTML = `Submissions ended on ${endDate.toLocaleDateString("en-US", { 
            year: "numeric", 
            month: "long", 
            day: "numeric" 
          })}.`;
        } else {
          const timeDiff = endDate.getTime() - now.getTime();
          
          const days = Math.floor(timeDiff / (1000 * 60 * 60 * 24));
          const hours = Math.floor((timeDiff % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
          const minutes = Math.floor((timeDiff % (1000 * 60 * 60)) / (1000 * 60));
          const seconds = Math.floor((timeDiff % (1000 * 60)) / 1000);
          
          timerElement.innerHTML = `Submissions end in <b>${days}d ${hours}h ${minutes}m ${seconds}s</b>.`;
        }
      }

      // Update immediately
      updateCountdown();
      
      // Update every second
      setInterval(updateCountdown, 1000);
    </script>


	</body>
</html>
