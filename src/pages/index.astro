---
import { TILE_SIZE, CANVAS_WIDTH, CANVAS_HEIGHT, FRAME_CREATE_FORM_URL } from "../config";
import { getCurrentUser } from "../lib/server-auth";

import prisma from "../lib/prisma";
import type * as db from "../prisma/generated/client";

const currentUser = await getCurrentUser(Astro);
let userFrames: db.Frame[] = [];
if (currentUser) {
  userFrames = await prisma.frame.findMany({
    where: { ownerId: currentUser.id }
  })
}
---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
    <link rel="preload" href={FRAME_CREATE_FORM_URL} as="document" />
		<title>&lt;iplace&gt;</title>
	</head>

  <style is:global>
    @import url('https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&display=swap');

    * {
      box-sizing: border-box;
      font-family: "IBM Plex Mono", "Cascadia Code", "JetBrains Mono", "Consolas", monospace;
    }

    html, body {
      overflow: hidden;
      width: 100%;
      height: 100%;
      margin: 0;
      border: none;
    }

    body {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      background: #aaa;
    }

    body, main {
      user-select: none;
    }

    main {
      background: #fff;
    }

    main.place-mode {
      background-image: 
        linear-gradient(to right, #ddd 1px, transparent 1px),
        linear-gradient(to bottom, #ddd 1px, transparent 1px);
      background-size: 100px 100px;
    }

    #hover-tile {
      position: absolute;
      width: 100px;
      height: 100px;
      background: rgba(0, 0, 0, 0.3);
      border: 2px solid #000;
      pointer-events: none;
      display: none;
      z-index: 5;
    }

    .tile {
      position: absolute;
      border: 1px solid #aaa;
      border-bottom: none;
      border-right: none;
      width: 100px;
      height: 100px;
    }

    body > * {
      position: absolute;
      top: 0;
      left: 0;
    }

    p {
      margin: 0;
    }

    #toolbox {
      width: 100%;
      height: 100%;
      padding: 2em;
    }

    #notice-overlay {
      padding: 2em;
      display: flex;
      width: 100%;
      height: 100%;
      justify-content: flex-end;
      z-index: 10;

      & .notice {
        width: 50%;
        height: min-content;
        display: flex;
        flex-direction: column;
        user-select: text;
        cursor: default;
        background: #fff;

        & .titlebar {
          padding: .5em 1em;
          border: 2px solid black;
          height: min-content;
          display: flex;
          justify-content: space-between;

          #notice-control {
            cursor: pointer;
          }
        }

        & .content {
          padding: 1em;
          border: 2px solid black;
          border-top: none;
          height: min-content;
          width: 100%;

          display: flex;
          flex-direction: column;
          gap: 1em;
        }
      }

      &.minimized {
        & .notice {
          width: 25%;
          transition: width .25s;

          &:hover {
            opacity: 1;
            width: 50%;
          }

          & .content {
            display: none;
          }
        }
      }
    }

    button {
      display: block;
      background: #fff;
      border: 2px solid #000;
      font-size: 1em;
      padding: .5em 1em;
      width: 100%;
      transition: color .25s, background .25s;
      cursor: pointer;
      
      &:hover:not(:disabled) {
        background: #000;
        color: #fff;
      }

      &:disabled {
        background: #f5f5f5;
        color: #999;
        border-color: #ccc;
        cursor: not-allowed;
      }
    }

    .buttons {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    details {
      &[open] {
        summary {
          &::marker {
            content: "[v] ";
          }
        }
      }

      summary {
        border: 2px solid black;
        padding: .5em 1em;
        cursor: pointer;

        transition: background .25s, color .25s;
        &:hover {
          background: #000;
          color: #fff;
        }

        &::marker {
          margin-right: 32px;
          content: "[>] ";
        }
      }
    }

    .frame-item {
      border: 2px solid #000;
      padding: 0.8em;
      margin: 0.5em 0;
      background: #fff;
      
      .frame-info {
        margin-bottom: 0.5em;
        
        strong {
          color: #000;
        }
        
        small {
          color: #000;
        }
      }
      
      .btn-place-tile {
        margin-top: 0.5em;
        background: #fff;
        color: #000;
        border: 2px solid #000;
        
        &:hover {
          background: #000;
          color: #fff;
        }
      }
    }

    #create-frame-modal, #project-selection-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 20;

      .modal-backdrop {
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 2em;
      }

      .modal-window {
        width: 90%;
        height: 90%;
        max-width: 900px;
        max-height: 900px;
        background: #fff;
        display: flex;
        flex-direction: column;
        
        .titlebar {
          padding: .5em 1em;
          border: 2px solid black;
          height: min-content;
          display: flex;
          justify-content: space-between;

          #modal-close {
            cursor: pointer;
          }
        }

        .modal-content {
          flex: 1;
          border: 2px solid black;
          border-top: none;
          overflow: hidden;

          iframe {
            border: none;
            display: block;
          }
        }
      }
    }

    .project-checkboxes {
      max-height: 300px;
      overflow-y: auto;
      border: 2px solid #000;
      padding: 1em;
      margin: 1em 0;
      background: #fff;

      .project-item {
        display: flex;
        align-items: center;
        gap: 0.5em;
        padding: 0.5em;
        cursor: pointer;
        border: 1px solid transparent;
        transition: background .25s, border-color .25s;

        &:hover {
          background: #f0f0f0;
          border-color: #000;
        }

        input[type="checkbox"] {
          appearance: none;
          width: 18px;
          height: 18px;
          border: 2px solid #000;
          background: #fff;
          margin: 0;
          cursor: pointer;
          flex-shrink: 0;

          &:checked {
            background: #000;
          }

          &:focus {
            outline: none;
          }

          &:hover {
            border-color: #000;
          }
        }

        label {
          cursor: pointer;
          flex: 1;
          font-weight: 400;
        }

        .project-name {
          flex: 1;
        }

        .project-time {
          font-size: 0.8em;
          color: #666;
          font-weight: 300;
        }
      }
    }

    .modal-hidden {
      display: none;
    }

    .modal-loading {
      text-align: center;
      padding: 2em;
    }

    .modal-error {
      display: none;
      text-align: center;
      padding: 2em;
    }

    .project-instruction {
      margin-bottom: 1em;
    }

    .modal-buttons {
      margin-top: 1em;
    }

    .selection-hint {
      font-size: 0.9em;
      color: #666;
      text-align: center;
      margin: 0.5em 0;
    }

    #project-selection-modal .modal-content {
      padding: 4em;
    }
  </style>

	<body>
    <main
      style={{
        width: `${TILE_SIZE * CANVAS_WIDTH}px`,
        height: `${TILE_SIZE * CANVAS_HEIGHT}px`
      }}
    />

    <div id="notice-overlay">
      <div class="notice">
        <div class="titlebar">
          <div>Hack Club's <b>&lt;iplace&gt;</b></div>
          <div role="button" title="Minimize" id="notice-control">[x]</div>
        </div>

        <div class="content">
          <p>
            This is a public canvas of <b>&lt;iframe&gt;</b> elements. Each hour of coding allows you to
            place one 100x100px tile and gives you <b>$5</b> in hosting credit!
          </p>

          { currentUser ? (
            <div class="buttons">
              <details>
                <summary>Your frames</summary>
                <div class="content">
                  { userFrames.length == 0 && <p>You have no frames yet!</p> }
                  
                  { userFrames.map(frame => {
                    const availableTiles = frame.isPending ? 0 : Math.max(0, Math.floor((frame.approvedTime || 0) / 3600) - frame.placedTiles);
                    return (
                      <div class="frame-item">
                        <div class="frame-info">
                          <strong>{frame.url}</strong>
                          <br />
                          <small>
                            Available tiles: {availableTiles}{frame.isPending ? ' / Pending' : ''}
                          </small>
                        </div>
                        {availableTiles > 0 && (
                          <button class="btn-place-tile" data-frame-id={frame.id}>
                            Place tile ({availableTiles} available)
                          </button>
                        )}
                      </div>
                    )
                  }) }

                  <button id="btn-create-frame">Create new frame</button>
                </div>
              </details>

              <button id="btn-place">Place a frame</button>
            </div>
          ) : (
            <div class="buttons">
              <button id="btn-login">Log in with Hack Club's Slack</button>
            </div>
          ) }
        </div>
      </div>
    </div>

    <div id="edit-layer">

    </div>

    { currentUser && (
      <div id="create-frame-modal" style="display: none;">
        <div class="modal-backdrop">
          <div class="modal-window">
            <div class="titlebar">
              <div>Create frame</div>
              <div role="button" title="Close" id="modal-close">[x]</div>
            </div>
            <div class="modal-content">
              <iframe id="create-frame-iframe" sandbox="allow-same-origin allow-scripts allow-forms" width="100%" height="100%"></iframe>
            </div>
          </div>
        </div>
      </div>
    ) }

    { currentUser && (
      <div id="project-selection-modal" class="modal-hidden">
        <div class="modal-backdrop">
          <div class="modal-window">
            <div class="titlebar">
              <div>Select Hackatime Projects</div>
              <div role="button" title="Close" id="project-modal-close">[x]</div>
            </div>
            <div class="modal-content">
              <div id="project-loading" class="modal-loading">
                Loading projects...
              </div>
              <div id="project-list" class="modal-hidden">
                <p class="project-instruction"><strong>Select at least one project</strong> to associate with this frame:</p>
                <div id="project-checkboxes" class="project-checkboxes">
                  <!-- Projects will be populated here -->
                </div>
                <div class="buttons modal-buttons">
                  <button id="continue-with-projects" disabled>Continue</button>
                  <p id="selection-hint" class="selection-hint">Please select at least one project to continue</p>
                </div>
              </div>
              <div id="project-error" class="modal-error">
                <p>Failed to load projects. You can continue without selecting projects.</p>
                <div class="buttons modal-buttons">
                  <button id="continue-without-projects">Continue anyway</button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
    ) }

    <div id="hover-tile"></div>
		
    <script>
      // Main canvas controller
      import { CANVAS_HEIGHT, CANVAS_WIDTH, TILE_SIZE } from "../config";
      import { assert, type Vector2 } from "../util";
      import type { ApiTile, ApiFrame, ApiMapResponse } from "./api/map";

      const body = document.body;
      const main = document.querySelector("main")!;

      let offset = { x: 0, y: 0 };
      let dragStart = { x: 0, y: 0 };
      let isDragging = false;

      const map: ApiMapResponse = await fetch("/api/map").then(x => x.json());
      console.log("(ok) map fetched!", map);

      const frames = new Map(map.frames.map(x => [x.id, x]));

      const tiles = new Array<ApiTile | undefined>(CANVAS_WIDTH * CANVAS_HEIGHT);
      for (const tile of map.tiles) {
        tiles[tile.x + (tile.y * CANVAS_WIDTH)] = tile;
      }

      const getTileByCoord = (x: number, y: number) => tiles[x + (y * CANVAS_WIDTH)];
      const getFrameById = (id: number) => frames.get(id);

      const loadedFrameIds = new Set<number>();

      /**
       * Converts a screen-space coordinate to a tile-space one.
       */
      function screenToTile(coord: Vector2): Vector2 {
        return {
          x: Math.max(0, Math.floor(coord.x / TILE_SIZE)),
          y: Math.max(0, Math.floor(coord.y / TILE_SIZE))
        };
      }

      async function setOffset(value: Vector2) {
        offset = value;
        main.style.transform = `translate(${offset.x}px, ${offset.y}px)`;

        const tlTile = screenToTile(value);
        const brTile = screenToTile({
          x: value.x + (CANVAS_WIDTH * TILE_SIZE),
          y: value.y + (CANVAS_HEIGHT * TILE_SIZE)
        });

        // Wait a short while, and check if the value has changed again - if so, we won't bother
        // with updating the tiles that were on the screen for less than (N)ms.
        // await sleep(50);
        if (value.x != offset.x || value.y != offset.y) {
          console.log("Value changed", value, offset);
          return;
        }

        // Load every tile in the visible region.
        for (let x = tlTile.x; x < brTile.x; x++) {
          for (let y = tlTile.y; y < brTile.y; y++) {
            updateTileAt(x, y);
          }
        }
      }

      function setIsDragging(value: boolean) {
        isDragging = value;
        body.style.cursor = value ? "grabbing" : "grab";
      }

      /**
       * Makes sure the tile at `(x, y)` is loaded, alongside its corresponding `<iframe>` element.
       */
      function updateTileAt(x: number, y: number) {
        const tile = getTileByCoord(x, y);
        if (!tile)
          return; // no tile is present at the given location

        const frame = getFrameById(tile?.frame);
        assert(frame != undefined);

        ensureFrameLoaded(frame);
      }

      function ensureFrameLoaded(frame: ApiFrame) {
        if (loadedFrameIds.has(frame.id))
          return;

        console.log("(ensureFrameLoaded) loading frame", frame);

        // Calculate the bounding box of the iframe. The bounding box encapsulates all of the tiles of
        // the frame in a tight fit.
        let x1 = Infinity, y1 = Infinity; // top-left, absolute
        let x2 = -Infinity, y2 = -Infinity; // bottom-right, absolute
        let layoutCount = 0;

        for (const tile of map.tiles) {
          if (tile.frame != frame.id)
            continue;

          layoutCount++;

          if (x1 > tile.x) { x1 = tile.x; }
          if (y1 > tile.y) { y1 = tile.y; }

          if (x2 < tile.x) { x2 = tile.x; }
          if (y2 < tile.y) { y2 = tile.y; }
        }
        
        assert(layoutCount != 0);
        assert(x1 != Infinity && y1 != Infinity, `x1 = ${x1}, y1 = ${y1}`);
        assert(x2 != -Infinity && y2 != -Infinity, `x2 = ${x2}, y2 = ${y2}`);

        const width = x2 - x1;
        const height = y2 - y1;

        // Now that we computed the width/height, let's check if the layout points form a rectangle.
        // If so, we can skip masking (since this iframe would cover the entire bounding rectangle)
        let needsMask = true;
        if (layoutCount == width * height) {
          needsMask = false;

          for (let x = x1; x < x2; x++) {
            for (let y = y1; y < y2; y++) {
              // If we're missing any tile in the rectangle, that means that we do have to compute a mask.
              const tile = getTileByCoord(x, y);
              if (!tile || tile.frame != frame.id) {
                needsMask = true;
                break;
              }
            }

            if (needsMask)
              break;
          }
        }

        const iframe = new HTMLIFrameElement();
        iframe.src = frame.url;
        iframe.loading = "lazy";
        iframe.sandbox = "allow-same-origin allow-scripts";
        iframe.width = `${width * TILE_SIZE}`;
        iframe.height = `${height * TILE_SIZE}`;
        iframe.style.left = `${x1 * TILE_SIZE}px`;
        iframe.style.top = `${y1 * TILE_SIZE}px`;
        iframe.allow = "accelerometer; cross-origin-isolated; gyroscope; magnetometer; encrypted-media";
        iframe.dataset.id = `${frame.id}`;
        iframe.className = "tile";

        // We might not need a mask - if this is a filled rect, then we can skip this step.
        if (needsMask) {
          let mask = `<svg xmlns="http://www.w3.org/2000/svg" width="${width * TILE_SIZE}" height="${height * TILE_SIZE}" viewBox="0 0 ${width * TILE_SIZE} ${height * TILE_SIZE}" fill="#000">`;
          
          for (const tile of map.tiles) {
            if (tile.frame != frame.id)
              continue;

            assert(tile.x >= x1 && tile.y >= y1, `x1 = ${x1}, tile.x = ${tile.x}, y1 = ${y1}, tile.y = ${tile.y}`);
            assert(tile.x <= x2 && tile.y <= y2, `x2 = ${x2}, tile.x = ${tile.x}, y2 = ${y2}, tile.y = ${tile.y}`);

            mask += `<rect width="${TILE_SIZE}" height="${TILE_SIZE}" x="${(tile.x - x1) * TILE_SIZE}" y="${(tile.y - y1) * TILE_SIZE}" />`;
          }

          mask += "</svg>";

          iframe.style.maskImage = `url("data:image/svg+xml;base64,${btoa(mask)}")`;
          iframe.style.maskMode = "luminance";
        }

        main.append(iframe);
        loadedFrameIds.add(frame.id);

        console.log("(ensureFrameLoaded) iframe created:", iframe);
      }

      body.addEventListener("mousedown", (ev) => {
        setIsDragging(true);
        dragStart = {
          x: ev.clientX - offset.x,
          y: ev.clientY - offset.y
        };

        if (isPlaceMode) {
          clickStartPos = { x: ev.clientX, y: ev.clientY };
        }
      });

      body.addEventListener("mousemove", (ev) => {
        if (!isDragging)
          return;

        setOffset({
          x: ev.clientX - dragStart.x,
          y: ev.clientY - dragStart.y
        });
      });

      body.addEventListener("mouseup", (ev) => {
        setIsDragging(false);
      });

      body.addEventListener("touchstart", (ev) => {
        const touch = ev.touches[0];
        setIsDragging(true);
        dragStart = {
          x: touch.clientX - offset.x,
          y: touch.clientY - offset.y
        };

        if (isPlaceMode) {
          clickStartPos = { x: touch.clientX, y: touch.clientY };
        }
      });

      body.addEventListener("touchmove", (ev) => {
        if (!isDragging)
          return;

        const touch = ev.touches[0];
        setOffset({
          x: touch.clientX - dragStart.x,
          y: touch.clientY - dragStart.y
        });
      });

      body.addEventListener("touchend", (ev) => {
        setIsDragging(false);
      });

      const btnPlace = document.querySelector<HTMLButtonElement>("#btn-place");
      const hoverTile = document.querySelector<HTMLDivElement>("#hover-tile")!;
      
      let isPlaceMode = false;
      let clickStartPos: Vector2 | null = null;
      let currentHoverTileX: number | null = null;
      let currentHoverTileY: number | null = null;

      function setPlaceMode(value: boolean) {
        isPlaceMode = value;
        main.classList.toggle("place-mode", value);
        hoverTile.style.display = value ? "block" : "none";
        
        if (btnPlace) {
          btnPlace.textContent = value ? "Exit place mode" : "Place a frame";
        }

        if (!value) {
          hoverTile.style.display = "none";
        }
      }

      function updateHoverTile(screenCoord: Vector2) {
        if (!isPlaceMode)
          return;

        const canvasX = screenCoord.x - offset.x; // screen-space -> canvas-space coords
        const canvasY = screenCoord.y - offset.y;
        const tileX = Math.floor(canvasX / TILE_SIZE);
        const tileY = Math.floor(canvasY / TILE_SIZE);

        if (tileX < 0 || tileX >= CANVAS_WIDTH || tileY < 0 || tileY >= CANVAS_HEIGHT) {
          // We're out-of-bounds here.
          hoverTile.style.display = "none";
          currentHoverTileX = null;
          currentHoverTileY = null;
          return;
        }

        hoverTile.style.left = `${(tileX * TILE_SIZE) + offset.x}px`;
        hoverTile.style.top = `${(tileY * TILE_SIZE) + offset.y}px`;
        hoverTile.style.display = "block";

        currentHoverTileX = tileX;
        currentHoverTileY = tileY;
      }

      if (btnPlace) {
        btnPlace.addEventListener("click", () => {
          setPlaceMode(!isPlaceMode);
        });
      }

      // Override existing mousemove handler to include place mode
      body.addEventListener("mousemove", (ev) => {
        if (isPlaceMode) {
          updateHoverTile({ x: ev.clientX, y: ev.clientY });
        }
      });

      body.addEventListener("click", (ev) => {
        if (isPlaceMode && clickStartPos) {
          if ((ev.target as Element).closest(".notice")) {
            clickStartPos = null;
            return;
          }
          
          // We don't want to capture clicks that might be drags.
          const deltaX = Math.abs(ev.clientX - clickStartPos.x);
          const deltaY = Math.abs(ev.clientY - clickStartPos.y);
          const maxClickDistance = 5; // pixels
          
          if (
            deltaX <= maxClickDistance &&
            deltaY <= maxClickDistance &&
            currentHoverTileX !== null &&
            currentHoverTileY !== null
          ) {
            handlePlace(currentHoverTileX, currentHoverTileY);
          }
          
          clickStartPos = null;
        }
      });

      function handlePlace(x: number, y: number) {
        alert(`Tile coordinates: (${x}, ${y})`);
      }
    </script>

    <script>
      // Top-right modal minimize/maximize
      const overlay = document.querySelector<HTMLDivElement>("#notice-overlay")!;
      const control = document.querySelector<HTMLDivElement>("#notice-control")!;
      control.addEventListener("click", () => {
        overlay.classList.toggle("minimized");
        control.innerText = overlay.classList.contains("minimized") ? "[^]" : "[x]";
      });
    </script>

    <script>
      // Login button controller
      const btnLogin = document.querySelector<HTMLButtonElement>("#btn-login");
      if (btnLogin) {
        btnLogin.addEventListener("click", () => {
          const url = new URL("https://slack.com/oauth/v2/authorize");
          url.searchParams.set("client_id", import.meta.env.PUBLIC_SLACK_CLIENT_ID);
          url.searchParams.set("user_scope", "identity.basic,identity.email");
          url.searchParams.set("redirect_uri", `${location.origin}/api/slack-callback`);

          location.href = url.toString();
        });
      }
    </script>

    <script>
      import { FRAME_CREATE_FORM_URL } from "../config";
      import { assert } from "../util";
      import type { ApiHackatimeProjectsResponse } from "./api/hackatime-projects";

      const btnCreateFrame = document.querySelector<HTMLButtonElement>("#btn-create-frame");
      const createFrameModal = document.querySelector<HTMLDivElement>("#create-frame-modal");
      const createFrameIframe = document.querySelector<HTMLIFrameElement>("#create-frame-iframe");
      const modalClose = document.querySelector<HTMLDivElement>("#modal-close");
      
      const projectSelectionModal = document.querySelector<HTMLDivElement>("#project-selection-modal");
      const projectModalClose = document.querySelector<HTMLDivElement>("#project-modal-close");
      const projectLoading = document.querySelector<HTMLDivElement>("#project-loading");
      const projectList = document.querySelector<HTMLDivElement>("#project-list");
      const projectError = document.querySelector<HTMLDivElement>("#project-error");
      const projectCheckboxes = document.querySelector<HTMLDivElement>("#project-checkboxes");
      const continueWithProjects = document.querySelector<HTMLButtonElement>("#continue-with-projects");
      const selectionHint = document.querySelector<HTMLParagraphElement>("#selection-hint");
      const continueWithoutProjects = document.querySelector<HTMLButtonElement>("#continue-without-projects");

      function formatTime(seconds: number): string {
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        if (hours > 0) {
          return `${hours}h ${minutes}m`;
        }
        return `${minutes}m`;
      }

      async function openCreateFrameModal(selectedProjects: string[] = []) {
        if (createFrameModal && createFrameIframe) {
          let url = FRAME_CREATE_FORM_URL;
          const params = new URLSearchParams();
          
          if (selectedProjects.length > 0) {
            params.set('hkp', selectedProjects.join(','));
          }
          
          const response = await fetch('/api/create-authorship-token', { method: 'POST' });
          assert(response.ok);

          const data = await response.json();
          params.set('atk', data.token);

          console.log(`(debug) form query params: ${params.toString()}`);
          
          url += `?${params.toString()}`;

          createFrameIframe.src = url;
          createFrameModal.style.display = "block";
        }
      }

      function closeProjectSelectionModal() {
        if (projectSelectionModal) {
          projectSelectionModal.classList.add("modal-hidden");
        }
      }

      function closeCreateFrameModal() {
        if (createFrameModal && createFrameIframe) {
          createFrameModal.style.display = "none";
          createFrameIframe.src = "";
        }
      }

      async function loadProjects() {
        try {
          if (!projectLoading || !projectList || !projectError || !projectCheckboxes) return;
          
          projectLoading.classList.remove("modal-hidden");
          projectList.classList.add("modal-hidden");
          projectError.classList.add("modal-hidden");

          const response = await fetch("/api/hackatime-projects", { method: "POST" });
          if (!response.ok) throw new Error("Failed to fetch projects");
          
          const data: ApiHackatimeProjectsResponse = await response.json();
          
          projectCheckboxes.innerHTML = "";
          
          if (data.projects.length === 0) {
            projectCheckboxes.innerHTML = "<p>No projects found. You can still create a frame without selecting projects.</p>";
          } else {
            data.projects.forEach(project => {
              const item = document.createElement("div");
              item.className = "project-item";
              item.innerHTML = `
                <input type="checkbox" id="project-${project.name}" value="${project.name}">
                <label for="project-${project.name}" class="project-name">${project.name}</label>
                <span class="project-time">${formatTime(project.seconds)}</span>
              `;
              
              const checkbox = item.querySelector('input[type="checkbox"]') as HTMLInputElement;
              if (checkbox) {
                checkbox.addEventListener('change', updateContinueButtonState);
              }
              
              projectCheckboxes.appendChild(item);
            });
          }
          
          // Update button state after loading projects
          updateContinueButtonState();
          
          projectLoading.classList.add("modal-hidden");
          projectList.classList.remove("modal-hidden");
        } catch (error) {
          console.error("Failed to load projects:", error);
          if (projectLoading) projectLoading.classList.add("modal-hidden");
          if (projectError) projectError.classList.remove("modal-hidden");
        }
      }

      function getSelectedProjects(): string[] {
        if (!projectCheckboxes) return [];
        const checkboxes = projectCheckboxes.querySelectorAll<HTMLInputElement>('input[type="checkbox"]:checked');
        return Array.from(checkboxes).map(cb => cb.value);
      }

      function updateContinueButtonState() {
        const selectedProjects = getSelectedProjects();
        const hasSelection = selectedProjects.length > 0;
        
        if (continueWithProjects) {
          continueWithProjects.disabled = !hasSelection;
        }
        
        if (selectionHint) {
          selectionHint.classList.toggle("modal-hidden", hasSelection);
        }
      }

      if (btnCreateFrame && projectSelectionModal) {
        btnCreateFrame.addEventListener("click", () => {
          projectSelectionModal.classList.remove("modal-hidden");
          loadProjects();
        });
      }

      if (projectModalClose) {
        projectModalClose.addEventListener("click", closeProjectSelectionModal);
      }

      if (projectSelectionModal) {
        projectSelectionModal.addEventListener("click", (ev) => {
          if (ev.target === projectSelectionModal || (ev.target as Element).classList.contains("modal-backdrop")) {
            closeProjectSelectionModal();
          }
        });
      }

      if (continueWithProjects) {
        continueWithProjects.addEventListener("click", () => {
          const selectedProjects = getSelectedProjects();
          if (selectedProjects.length > 0) {
            closeProjectSelectionModal();
            openCreateFrameModal(selectedProjects);
          }
        });
      }

      if (continueWithoutProjects) {
        continueWithoutProjects.addEventListener("click", () => {
          closeProjectSelectionModal();
          openCreateFrameModal();
        });
      }

      if (modalClose) {
        modalClose.addEventListener("click", closeCreateFrameModal);
      }

      if (createFrameModal) {
        createFrameModal.addEventListener("click", (ev) => {
          if (ev.target === createFrameModal || (ev.target as Element).classList.contains("modal-backdrop")) {
            closeCreateFrameModal();
          }
        });
      }

      // Listen for frame creation completion from iframe
      window.addEventListener("message", (event) => {
        // Verify the origin for security
        if (event.origin !== window.location.origin) {
          return;
        }
        
        if (event.data && event.data.type === "frameCreated") {
          console.log("Frame created:", event.data.frame);
          
          // Close the modal
          closeCreateFrameModal();
          
          // Refresh the page to show the new frame
          window.location.reload();
        }
      });
    </script>


	</body>
</html>
